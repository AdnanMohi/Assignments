{"version":3,"file":"376.184993b074e6e2099eb8.js","mappings":"kfAEA,IAAKA,EAAAA,SACD,MAAM,IAAIC,MAAM,qDAEpB,IAAKC,EAAAA,IACD,MAAM,IAAID,MAAM,oE,cCNhBE,EAAkC,SAAUC,EAAGC,GAC/C,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBK,EAAYC,EAA3BC,EAAIL,EAAEM,KAAKR,GAAOS,EAAK,GAC3B,IACI,WAAc,IAANR,GAAgBA,KAAM,MAAQI,EAAIE,EAAEG,QAAQC,MAAMF,EAAGG,KAAKP,EAAEQ,MAQxE,CANA,MAAOC,GAASR,EAAI,CAAEQ,MAAOA,EAAS,CAAC,QAEnC,IACQT,IAAMA,EAAEM,OAAST,EAAIK,EAAU,SAAIL,EAAEM,KAAKD,EAElB,CAD/B,QACS,GAAID,EAAG,MAAMA,EAAEQ,KAAO,CACpC,CACA,OAAOL,CACX,EAMO,SAASM,IACZ,IAAiCC,EAAxBjB,GAAOH,EAAAA,EAAAA,UAAS,GAAI,GAAiB,GAI9C,OAHaqB,EAAAA,EAAAA,cAAY,WACrBD,GAAQ,SAAUE,GAAQ,OAAOA,EAAO,CAAG,GAC/C,GAAG,GAEP,CAcA,IAAIC,EAAa,CAAC,ECvClB,IDiC0BC,ECjCtBC,GDiCsBD,ECjCuB,mBDkCvB,mBAAXjB,OACAA,OAAOmB,IAAIF,GAEf,iBAAmBA,EAAO,MCpC9B,SAASG,EAAiBC,GAC7BA,GACJ,CACO,SAASC,EAAiBC,GACxBA,IACDA,EAAoBH,IAKxBI,EAAAA,EAAAA,WAAU,CAAED,kBAAmBA,KD8BT,oBAAXE,OACAA,YAEW,IAAXC,EAAAA,EACAA,EAAAA,EAES,oBAATC,KACAA,KAEJX,GCtCKE,IAAoC,CACpD,CACO,IChBHU,GAA+B,EAC5B,SAASC,EAAmBC,GAC/BF,EAA+BE,CACnC,CACO,SAASC,IACZ,OAAOH,CACX,CCLO,SAASI,EAAgBC,GAC5B,OAAOC,EAAAA,EAAAA,mBAAkBD,EAC7B,CCUO,IAYHE,EAZOC,EAAwC,IAQ/CC,EAA0B,IAAIC,IAKlC,SAASC,SACyBC,IAA1BL,IACAA,EAAwBM,WAAWC,EAXJ,KAavC,CAWA,SAASA,IACLP,OAAwBK,EAGxB,IAAIG,EAAMC,KAAKD,MACfN,EAAwBQ,SAAQ,SAAUC,GACtC,IAAIC,EAAWD,EAAIE,QACfD,GACIJ,GAAOI,EAASE,UAEhBF,EAASG,SAASC,UAClBL,EAAIE,QAAU,KACdX,EAAwBe,OAAON,GAG3C,IACIT,EAAwBgB,KAAO,GAG/Bd,GAER,CC7DA,IAAIe,GAAe,EACfC,EAAmB,GCKvB,IAAIC,EAAe,CAAC,EACpB,SAASC,EAAyBC,GAC9B,MAAO,WAAaA,CACxB,CACO,SAASC,EAAYC,EAAIF,EAAmBG,GAG/C,QAF0B,IAAtBH,IAAgCA,EAAoB,iBACxC,IAAZG,IAAsBA,EAAUL,GAChCzB,IACA,OAAO6B,IAEX,IFc8Cd,EEZ1CgB,EDhBD,SAA8BC,GACjC,OAAO,WACCT,EACAC,EAAiB9C,KAAKsD,GAGtBA,GAER,CACJ,CCO4BC,EAFIH,EAAQjD,gBAAkBA,MAMlDqD,EAAsBC,IAAAA,OAAa,MACvC,IAAKD,EAAoBjB,QAAS,CAG9B,IAAImB,EAAgB,IAAIC,EAAAA,SAASX,EAAyBC,IAAoB,WAMtEW,EAAeC,QAEfR,KAMAK,EAAchB,UACdc,EAAoBjB,QAAU,KAEtC,IACIqB,EF7CL,SAA4BnB,GAK/B,MAJmB,CACfD,QAASL,KAAKD,MAAQP,EACtBc,SAAUA,EAGlB,CEuC6BqB,CAAmBJ,GACxCF,EAAoBjB,QAAUqB,EFfYvB,EEgBRmB,EFftC5B,EAAwBmC,IAAI1B,GAC5BP,GEeA,CACA,IAAIW,EAAWe,EAAoBjB,QAAQE,SAiC3C,OAhCAgB,IAAAA,cAAoBhB,EAAUlB,GAC9BkC,IAAAA,WAAgB,WFhBb,IAAmCO,EEyClC,OFzCkCA,EEkBRR,EFjB9B5B,EAAwBe,OAAOqB,GEkBvBR,EAAoBjB,QAIpBiB,EAAoBjB,QAAQsB,SAAU,GAStCL,EAAoBjB,QAAU,CAC1BE,SAAU,IAAIkB,EAAAA,SAASX,EAAyBC,IAAoB,WAEhEI,GACJ,IACAb,QAASyB,KAEbZ,KAEG,WACHG,EAAoBjB,QAAQE,SAASC,UACrCc,EAAoBjB,QAAU,IAClC,CACJ,GAAG,IDnEA,SAAmC3B,GAEtCiC,GAAe,EACfC,EAAmB,GACnB,IACI,IAAIoB,EAAStD,IAEbiC,GAAe,EAEf,IAAIsB,EAAUrB,EAAiBsB,OAAS,EAAItB,OAAmBf,EAO/D,OALA0B,IAAAA,iBAAsB,WACdU,GACAA,EAAQ/B,SAAQ,SAAUiC,GAAK,OAAOA,GAAK,GAEnD,GAAG,CAACF,IACGD,CAIX,CAHC,QAEGrB,GAAe,CACnB,CACJ,CCgDWyB,EAA0B,WAI7B,IAAIC,EACAC,EASJ,GARA/B,EAASgC,OAAM,WACX,IACIF,EAAYpB,GAIhB,CAFA,MAAOzD,GACH8E,EAAY9E,CAChB,CACJ,IACI8E,EACA,MAAMA,EAEV,OAAOD,CACX,GACJ,CCrGA,IAAIG,EAAsC,WAStC,OARAA,EAAWC,OAAOC,QAAU,SAASC,GACjC,IAAK,IAAIC,EAAGnF,EAAI,EAAGN,EAAI0F,UAAUX,OAAQzE,EAAIN,EAAGM,IAE5C,IAAK,IAAIqF,KADTF,EAAIC,UAAUpF,GACOgF,OAAOM,UAAUC,eAAetF,KAAKkF,EAAGE,KACzDH,EAAEG,GAAKF,EAAEE,IAEjB,OAAOH,CACX,EACOH,EAASS,MAAMC,KAAML,UAChC,EAKO,SAASM,EAASC,EAAelC,GAEpC,GAAI9B,IACA,OAAOgE,EAEX,IASIC,EAsBsBC,EAAMC,EA/B5BC,EAAchB,EAAS,CAAEiB,YAAY,GAASvC,GAC9CH,EAAoBqC,EAAcM,aAAeN,EAAc9E,KAC/DqF,EAAmB,SAAUC,EAAOzD,GACpC,OAAOa,GAAY,WAAc,OAAOoC,EAAcQ,EAAOzD,EAAM,GAAGY,EAC1E,EAkBA,OAjBA4C,EAAiBD,YAAc3C,EAU3BsC,EALAG,EAAYC,YAKII,EAAAA,EAAAA,OAAKJ,EAAAA,EAAAA,YAAWE,KAGhBE,EAAAA,EAAAA,MAAKF,GAaCL,EAXLF,EAWWG,EAXIF,EAYpCZ,OAAOqB,KAAKR,GAAMpD,SAAQ,SAAU6D,GAC3BC,EAAeD,IAChBtB,OAAOwB,eAAeV,EAAQQ,EAAKtB,OAAOyB,yBAAyBZ,EAAMS,GAEjF,IAfAV,EAAcK,YAAc3C,EACrBsC,CACX,CAEA,IAAIW,EAAiB,CACjBG,UAAU,EACVC,QAAQ,EACRC,SAAS,EACTC,MAAM,GChDV,SAASC,EAAkBC,GACvB,IAAIC,EAAWD,EAAGC,SAAUL,EAASI,EAAGJ,OACpCM,EAAYD,GAAYL,EAC5B,MAAyB,mBAAdM,EACA,KAEJ1D,EAAY0D,EACvB,CAOA,SAASC,EAAmBf,EAAOG,EAAKa,EAAeC,EAAUC,GAC7D,IAAIC,EAAmB,aAARhB,EAAqB,SAAW,WAC3CiB,EAAgC,mBAAfpB,EAAMG,GACvBkB,EAA0C,mBAApBrB,EAAMmB,GAChC,OAAIC,GAAWC,EACJ,IAAIlI,MAAM,qEAAuE6H,GAExFI,GAAWC,EACJ,KAEJ,IAAIlI,MAAM,iBACb+H,EACA,qBACOlB,EAAMG,GAHA,kBAMba,EACA,0BACR,CAxBAL,EAAkBW,UAAY,CAC1BT,SAAUE,EACVP,OAAQO,GAEZJ,EAAkBb,YAAc,WCbhC,IAAIzG,EAAkC,SAAUC,EAAGC,GAC/C,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBK,EAAYC,EAA3BC,EAAIL,EAAEM,KAAKR,GAAOS,EAAK,GAC3B,IACI,WAAc,IAANR,GAAgBA,KAAM,MAAQI,EAAIE,EAAEG,QAAQC,MAAMF,EAAGG,KAAKP,EAAEQ,MAQxE,CANA,MAAOC,GAASR,EAAI,CAAEQ,MAAOA,EAAS,CAAC,QAEnC,IACQT,IAAMA,EAAEM,OAAST,EAAIK,EAAU,SAAIL,EAAEM,KAAKD,EAElB,CAD/B,QACS,GAAID,EAAG,MAAMA,EAAEQ,KAAO,CACpC,CACA,OAAOL,CACX,EAIO,SAASwH,EAA8B9E,EAAS+E,GASnD,IAAIA,QAAgCvF,IAAZQ,EAAxB,CAGI,EAGJ,IAAsGgF,EAA7FpI,EAAOsE,IAAAA,UAAe,WAAc,OAAO+D,EAAAA,EAAAA,YAAWjF,EAAS,CAAC,EAAG,CAAEkF,MAAM,GAAU,IAAI,GAAa,GAQ/G,OAHAC,EAAAA,EAAAA,cAAY,WACR/C,OAAOC,OAAO2C,EAAKhF,EACvB,IACOgF,CAZP,CAaJ,CACO,SAASI,EAAsBpF,GAClC,OAAO8E,EAA8B9E,GAAS,EAClD,CC1CO,SAASqF,EAAcC,EAAatF,GACvC,IAAIuF,EAAST,EAA8B9E,GAAS,GACpD,OAAOkB,IAAAA,UAAe,WAClB,IAAIsE,GAAQP,EAAAA,EAAAA,YAAWK,EAAYC,IAYnC,OVSD,SAAuB7H,GAC1B,IAAKA,GAA0B,iBAAVA,EACjB,OAAO,EAEX,IAAI+H,EAAQrD,OAAOsD,eAAehI,GAClC,OAAQ+H,GAASA,IAAUrD,OAAOM,SACtC,CU1BYiD,CAAcH,KACdL,EAAAA,EAAAA,cAAY,WACR/C,OAAOqB,KAAK+B,GAAO3F,SAAQ,SAAU6D,GACjC,IAYO9C,EAAIgF,EAZPlI,EAAQ8H,EAAM9B,GACG,mBAAVhG,IAEP8H,EAAM9B,IASH9C,EAT4BlD,EASxBkI,EAT+BJ,EAUnD,WAEH,IADA,IAAIK,EAAO,GACFC,EAAK,EAAGA,EAAKtD,UAAUX,OAAQiE,IACpCD,EAAKC,GAAMtD,UAAUsD,GAEzB,OAAOC,EAAAA,EAAAA,cAAY,WAAc,OAAOnF,EAAGgC,MAAMgD,EAASC,EAAO,GACrE,GAdY,GACJ,IAEGL,CACX,IAAG,EACP,CClBAlH,EAAiB0H,EAAAA,yB","sources":["webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/assertEnvironment.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/utils.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/observerBatching.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/staticRendering.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/printDebugValue.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/reactionCleanupTracking.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/useQueuedForceUpdate.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/useObserver.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/observer.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/ObserverComponent.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/useAsObservableSource.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/useLocalStore.js","webpack://mosaicProviderJobcards/./node_modules/mobx-react-lite/es/index.js"],"sourcesContent":["import { spy } from \"mobx\";\nimport { useState } from \"react\";\nif (!useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!spy) {\n    throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\");\n}\n","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useCallback, useEffect, useState } from \"react\";\nvar EMPTY_ARRAY = [];\nexport function useUnmount(fn) {\n    useEffect(function () { return fn; }, EMPTY_ARRAY);\n}\nexport function useForceUpdate() {\n    var _a = __read(useState(0), 2), setTick = _a[1];\n    var update = useCallback(function () {\n        setTick(function (tick) { return tick + 1; });\n    }, []);\n    return update;\n}\nexport function isPlainObject(value) {\n    if (!value || typeof value !== \"object\") {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    return !proto || proto === Object.prototype;\n}\nexport function getSymbol(name) {\n    if (typeof Symbol === \"function\") {\n        return Symbol.for(name);\n    }\n    return \"__$mobx-react \" + name + \"__\";\n}\nvar mockGlobal = {};\nexport function getGlobal() {\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return mockGlobal;\n}\n","import { configure } from \"mobx\";\nimport { getGlobal, getSymbol } from \"./utils\";\nvar observerBatchingConfiguredSymbol = getSymbol(\"observerBatching\");\nexport function defaultNoopBatch(callback) {\n    callback();\n}\nexport function observerBatching(reactionScheduler) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch;\n        if (\"production\" !== process.env.NODE_ENV) {\n            console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n        }\n    }\n    configure({ reactionScheduler: reactionScheduler });\n    getGlobal()[observerBatchingConfiguredSymbol] = true;\n}\nexport var isObserverBatched = function () { return !!getGlobal()[observerBatchingConfiguredSymbol]; };\n","var globalIsUsingStaticRendering = false;\nexport function useStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nexport function isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n","import { getDependencyTree } from \"mobx\";\nexport function printDebugValue(v) {\n    return getDependencyTree(v);\n}\n","export function createTrackingData(reaction) {\n    var trackingData = {\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n        reaction: reaction\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n/**\n * Reactions created by components that have yet to be fully mounted.\n */\nvar uncommittedReactionRefs = new Set();\n/**\n * Latest 'uncommitted reactions' cleanup timer handle.\n */\nvar reactionCleanupHandle;\nfunction ensureCleanupTimerRunning() {\n    if (reactionCleanupHandle === undefined) {\n        reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n    }\n}\nexport function scheduleCleanupOfReactionIfLeaked(ref) {\n    uncommittedReactionRefs.add(ref);\n    ensureCleanupTimerRunning();\n}\nexport function recordReactionAsCommitted(reactionRef) {\n    uncommittedReactionRefs.delete(reactionRef);\n}\n/**\n * Run by the cleanup timer to dispose any outstanding reactions\n */\nfunction cleanUncommittedReactions() {\n    reactionCleanupHandle = undefined;\n    // Loop through all the candidate leaked reactions; those older\n    // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n    var now = Date.now();\n    uncommittedReactionRefs.forEach(function (ref) {\n        var tracking = ref.current;\n        if (tracking) {\n            if (now >= tracking.cleanAt) {\n                // It's time to tidy up this leaked reaction.\n                tracking.reaction.dispose();\n                ref.current = null;\n                uncommittedReactionRefs.delete(ref);\n            }\n        }\n    });\n    if (uncommittedReactionRefs.size > 0) {\n        // We've just finished a round of cleanups but there are still\n        // some leak candidates outstanding.\n        ensureCleanupTimerRunning();\n    }\n}\n/* istanbul ignore next */\n/**\n * Only to be used by test functions; do not export outside of mobx-react-lite\n */\nexport function forceCleanupTimerToRunNowForTests() {\n    // This allows us to control the execution of the cleanup timer\n    // to force it to run at awkward times in unit tests.\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        cleanUncommittedReactions();\n    }\n}\n/* istanbul ignore next */\nexport function resetCleanupScheduleForTests() {\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        reactionCleanupHandle = undefined;\n    }\n    uncommittedReactionRefs.clear();\n}\n","import React from \"react\";\nvar insideRender = false;\nvar forceUpdateQueue = [];\nexport function useQueuedForceUpdate(forceUpdate) {\n    return function () {\n        if (insideRender) {\n            forceUpdateQueue.push(forceUpdate);\n        }\n        else {\n            forceUpdate();\n        }\n    };\n}\nexport function useQueuedForceUpdateBlock(callback) {\n    // start intercepting force-update calls\n    insideRender = true;\n    forceUpdateQueue = [];\n    try {\n        var result = callback();\n        // stop intercepting force-update\n        insideRender = false;\n        // store queue or nothing if it was empty to execute useLayoutEffect only when necessary\n        var queue_1 = forceUpdateQueue.length > 0 ? forceUpdateQueue : undefined;\n        // run force-update queue in useLayoutEffect\n        React.useLayoutEffect(function () {\n            if (queue_1) {\n                queue_1.forEach(function (x) { return x(); });\n            }\n        }, [queue_1]);\n        return result;\n    }\n    finally {\n        insideRender = false;\n    }\n}\n","import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils\";\nimport { useQueuedForceUpdate, useQueuedForceUpdateBlock } from \"./useQueuedForceUpdate\";\nvar EMPTY_OBJECT = {};\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\nexport function useObserver(fn, baseComponentName, options) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\n    var forceUpdate = wantedForceUpdateHook();\n    var queuedForceUpdate = useQueuedForceUpdate(forceUpdate);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                queuedForceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\n                // drop our current reaction and allow useEffect() to recreate it.\n                newReaction_1.dispose();\n                reactionTrackingRef.current = null;\n            }\n        });\n        var trackingData_1 = createTrackingData(newReaction_1);\n        reactionTrackingRef.current = trackingData_1;\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This is either due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up, or we got a observable change\n            // between render and useEffect\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    queuedForceUpdate();\n                }),\n                cleanAt: Infinity\n            };\n            queuedForceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // delay all force-update calls after rendering of this component\n    return useQueuedForceUpdateBlock(function () {\n        // render the original component, but have the\n        // reaction track the observables, so that rendering\n        // can be invalidated (see above) once a dependency changes\n        var rendering;\n        var exception;\n        reaction.track(function () {\n            try {\n                rendering = fn();\n            }\n            catch (e) {\n                exception = e;\n            }\n        });\n        if (exception) {\n            throw exception; // re-throw any exceptions caught during rendering\n        }\n        return rendering;\n    });\n}\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { forwardRef, memo } from \"react\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useObserver } from \"./useObserver\";\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer(baseComponent, options) {\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent;\n    }\n    var realOptions = __assign({ forwardRef: false }, options);\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    var wrappedComponent = function (props, ref) {\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\n    };\n    wrappedComponent.displayName = baseComponentName;\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    var memoComponent;\n    if (realOptions.forwardRef) {\n        // we have to use forwardRef here because:\n        // 1. it cannot go before memo, only after it\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n        //    since it wouldn't be a callable function anymore\n        memoComponent = memo(forwardRef(wrappedComponent));\n    }\n    else {\n        memoComponent = memo(wrappedComponent);\n    }\n    copyStaticProperties(baseComponent, memoComponent);\n    memoComponent.displayName = baseComponentName;\n    return memoComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n","import { useObserver } from \"./useObserver\";\nfunction ObserverComponent(_a) {\n    var children = _a.children, render = _a.render;\n    var component = children || render;\n    if (typeof component !== \"function\") {\n        return null;\n    }\n    return useObserver(component);\n}\nObserverComponent.propTypes = {\n    children: ObserverPropsCheck,\n    render: ObserverPropsCheck\n};\nObserverComponent.displayName = \"Observer\";\nexport { ObserverComponent as Observer };\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\n    var hasProp = typeof props[key] === \"function\";\n    var hasExtraProp = typeof props[extraKey] === \"function\";\n    if (hasProp && hasExtraProp) {\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n    }\n    if (hasProp || hasExtraProp) {\n        return null;\n    }\n    return new Error(\"Invalid prop `\" +\n        propFullName +\n        \"` of type `\" +\n        typeof props[key] +\n        \"` supplied to\" +\n        \" `\" +\n        componentName +\n        \"`, expected `function`.\");\n}\n","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { observable, runInAction } from \"mobx\";\nimport React from \"react\";\nimport { isPlainObject } from \"./utils\";\nexport function useAsObservableSourceInternal(current, usedByLocalStore) {\n    var culprit = usedByLocalStore ? \"useLocalStore\" : \"useAsObservableSource\";\n    if (\"production\" !== process.env.NODE_ENV && usedByLocalStore) {\n        var _a = __read(React.useState(current), 1), initialSource = _a[0];\n        if ((initialSource !== undefined && current === undefined) ||\n            (initialSource === undefined && current !== undefined)) {\n            throw new Error(\"make sure you never pass `undefined` to \" + culprit);\n        }\n    }\n    if (usedByLocalStore && current === undefined) {\n        return undefined;\n    }\n    if (\"production\" !== process.env.NODE_ENV && !isPlainObject(current)) {\n        throw new Error(culprit + \" expects a plain object as \" + (usedByLocalStore ? \"second\" : \"first\") + \" argument\");\n    }\n    var _b = __read(React.useState(function () { return observable(current, {}, { deep: false }); }), 1), res = _b[0];\n    if (\"production\" !== process.env.NODE_ENV &&\n        Object.keys(res).length !== Object.keys(current).length) {\n        throw new Error(\"the shape of objects passed to \" + culprit + \" should be stable\");\n    }\n    runInAction(function () {\n        Object.assign(res, current);\n    });\n    return res;\n}\nexport function useAsObservableSource(current) {\n    return useAsObservableSourceInternal(current, false);\n}\n","import { observable, runInAction, transaction } from \"mobx\";\nimport React from \"react\";\nimport { useAsObservableSourceInternal } from \"./useAsObservableSource\";\nimport { isPlainObject } from \"./utils\";\nexport function useLocalStore(initializer, current) {\n    var source = useAsObservableSourceInternal(current, true);\n    return React.useState(function () {\n        var local = observable(initializer(source));\n        if (isPlainObject(local)) {\n            runInAction(function () {\n                Object.keys(local).forEach(function (key) {\n                    var value = local[key];\n                    if (typeof value === \"function\") {\n                        // @ts-ignore No idea why ts2536 is popping out here\n                        local[key] = wrapInTransaction(value, local);\n                    }\n                });\n            });\n        }\n        return local;\n    })[0];\n}\n// tslint:disable-next-line: ban-types\nfunction wrapInTransaction(fn, context) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return transaction(function () { return fn.apply(context, args); });\n    };\n}\n","import \"./assertEnvironment\";\nimport { unstable_batchedUpdates as batch } from \"./utils/reactBatchedUpdates\";\nimport { observerBatching } from \"./observerBatching\";\nobserverBatching(batch);\nexport { isUsingStaticRendering, useStaticRendering } from \"./staticRendering\";\nexport { observer } from \"./observer\";\nexport { useObserver } from \"./useObserver\";\nexport { Observer } from \"./ObserverComponent\";\nexport { useForceUpdate } from \"./utils\";\nexport { useAsObservableSource } from \"./useAsObservableSource\";\nexport { useLocalStore } from \"./useLocalStore\";\nexport { useQueuedForceUpdate, useQueuedForceUpdateBlock } from \"./useQueuedForceUpdate\";\nexport { isObserverBatched, observerBatching } from \"./observerBatching\";\n"],"names":["useState","Error","spy","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","useForceUpdate","setTick","useCallback","tick","mockGlobal","name","observerBatchingConfiguredSymbol","for","defaultNoopBatch","callback","observerBatching","reactionScheduler","configure","window","global","self","globalIsUsingStaticRendering","useStaticRendering","enable","isUsingStaticRendering","printDebugValue","v","getDependencyTree","reactionCleanupHandle","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","undefined","setTimeout","cleanUncommittedReactions","now","Date","forEach","ref","tracking","current","cleanAt","reaction","dispose","delete","size","insideRender","forceUpdateQueue","EMPTY_OBJECT","observerComponentNameFor","baseComponentName","useObserver","fn","options","queuedForceUpdate","forceUpdate","useQueuedForceUpdate","reactionTrackingRef","React","newReaction_1","Reaction","trackingData_1","mounted","createTrackingData","add","reactionRef","Infinity","result","queue_1","length","x","useQueuedForceUpdateBlock","rendering","exception","track","__assign","Object","assign","t","s","arguments","p","prototype","hasOwnProperty","apply","this","observer","baseComponent","memoComponent","base","target","realOptions","forwardRef","displayName","wrappedComponent","props","memo","keys","key","hoistBlackList","defineProperty","getOwnPropertyDescriptor","$$typeof","render","compare","type","ObserverComponent","_a","children","component","ObserverPropsCheck","componentName","location","propFullName","extraKey","hasProp","hasExtraProp","propTypes","useAsObservableSourceInternal","usedByLocalStore","res","observable","deep","runInAction","useAsObservableSource","useLocalStore","initializer","source","local","proto","getPrototypeOf","isPlainObject","context","args","_i","transaction","batch"],"sourceRoot":""}